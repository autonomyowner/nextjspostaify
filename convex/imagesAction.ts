"use node";

import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import { authComponent } from "./auth";
import { canAccessModel, getModelRequiredPlan, Plan } from "./lib/planLimits";

// Provider types
type ImageProvider = "runware" | "fal";

// Model to provider mapping - Runware for Flux, Fal.ai for Ideogram/Bria
function getProvider(model: string): ImageProvider {
  if (model.includes("ideogram") || model.includes("bria")) {
    return "fal";
  }
  return "runware";
}

// Runware model ID mapping
// Pricing: https://runware.ai/pricing
// - FLUX.2 [klein] 4B: $0.0006/image (cheapest, sub-second, best for FREE tier)
// - Flux Schnell: $0.0006/image (fast, good quality)
// - Flux Dev: $0.0038/image (higher quality)
// - HiDream-I1 Fast: $0.0032/image (good but 5x more expensive)
function getRunwareModelId(model: string): string {
  const modelMap: Record<string, string> = {
    "fal-ai/flux/schnell": "runware:400@4", // FLUX.2 [klein] 4B - $0.0006, sub-second (FREE tier)
    "fal-ai/flux/dev": "runware:101@1", // Flux Dev - $0.0038 (PRO tier)
    "fal-ai/flux-pro": "civitai:618692@691639", // Flux Pro 1.1 (PRO tier)
    "fal-ai/flux-pro/v1.1": "civitai:618692@691639", // Flux Pro 1.1 (PRO tier)
    "fal-ai/recraft-v3": "runware:2@1", // Recraft V3 (BUSINESS tier)
  };
  return modelMap[model] || "runware:400@4"; // Default to FLUX.2 klein 4B (cheapest)
}

// Runware image generation
async function generateWithRunware(
  prompt: string,
  model: string,
  width: number,
  height: number,
  apiKey: string
): Promise<string> {
  const runwareModel = getRunwareModelId(model);

  const response = await fetch("https://api.runware.ai/v1", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify([
      {
        taskType: "imageInference",
        taskUUID: crypto.randomUUID(),
        positivePrompt: prompt,
        model: runwareModel,
        width,
        height,
        numberResults: 1,
        outputFormat: "png",
        outputQuality: 95,
        outputType: "URL",
        includeCost: false,
        CFGScale: 7,
        scheduler: "FlowMatchEulerDiscreteScheduler",
        strength: 0.8,
      },
    ]),
  });

  if (!response.ok) {
    const errorText = await response.text().catch(() => "");
    if (response.status === 401) {
      throw new Error("Invalid Runware API key");
    }
    if (response.status === 402) {
      throw new Error("Insufficient Runware credits");
    }
    throw new Error(
      `Runware API error: ${errorText || response.statusText}`
    );
  }

  const result = (await response.json()) as {
    data?: Array<{ imageURL?: string }>;
  };

  if (!result.data || result.data.length === 0 || !result.data[0].imageURL) {
    throw new Error("No image was generated by Runware");
  }

  return result.data[0].imageURL;
}

// Fal.ai image generation (existing logic)
async function generateWithFal(
  prompt: string,
  model: string,
  imageSize: { width: number; height: number },
  aspectRatio: string,
  apiKey: string
): Promise<string> {
  let requestBody: Record<string, unknown>;

  if (isIdeogramModel(model)) {
    requestBody = {
      prompt,
      aspect_ratio: aspectRatio,
      expand_prompt: true,
      style: "auto",
    };
  } else {
    requestBody = {
      prompt,
      image_size: imageSize,
      num_images: 1,
      enable_safety_checker: true,
      output_format: "png",
    };
  }

  const response = await fetch(`https://fal.run/${model}`, {
    method: "POST",
    headers: {
      Authorization: `Key ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    if (response.status === 401) {
      throw new Error("Invalid Fal.ai API key");
    }
    if (response.status === 402) {
      throw new Error("Insufficient Fal.ai credits");
    }
    const errorText = await response.text().catch(() => "");
    throw new Error(
      `Fal.ai API error: ${errorText || response.statusText}`
    );
  }

  const result = (await response.json()) as {
    images?: Array<{ url: string }>;
  };

  if (!result.images || result.images.length === 0) {
    throw new Error("No image was generated by Fal.ai");
  }

  return result.images[0].url;
}

// Style-specific enhancements
const styleEnhancements: Record<string, string> = {
  none: "",
  photorealistic:
    "photorealistic, highly detailed, professional photography, 8k resolution",
  "digital-art": "digital art style, vibrant colors, detailed illustration",
  illustration: "illustration style, artistic, clean lines, stylized",
  cinematic:
    "cinematic lighting, dramatic atmosphere, movie still, professional color grading",
  minimalist: "minimalist design, clean, simple, elegant, white space",
  vibrant: "vibrant colors, bold, eye-catching, high contrast, energetic",
};

// Quality keywords to add for professional results
const QUALITY_BOOSTERS = [
  "high quality",
  "detailed",
  "professional",
  "sharp focus",
  "well-composed",
];

// Lighting enhancements
const LIGHTING_TERMS = [
  "beautiful lighting",
  "soft natural light",
  "golden hour lighting",
  "studio lighting",
  "dramatic lighting",
];

// Composition terms
const COMPOSITION_TERMS = [
  "rule of thirds",
  "balanced composition",
  "centered subject",
  "dynamic angle",
];

// Check if prompt already has quality/technical terms
function hasQualityTerms(prompt: string): boolean {
  const qualityIndicators = [
    "detailed", "quality", "professional", "8k", "4k", "hd", "realistic",
    "lighting", "composition", "sharp", "vivid", "stunning", "beautiful",
    "masterpiece", "award", "artistic", "render", "resolution"
  ];
  const lowerPrompt = prompt.toLowerCase();
  return qualityIndicators.some(term => lowerPrompt.includes(term));
}

// Detect subject type for context-aware enhancement
function detectSubjectType(prompt: string): string {
  const lowerPrompt = prompt.toLowerCase();

  if (/person|people|man|woman|portrait|face|human/.test(lowerPrompt)) {
    return "portrait";
  }
  if (/landscape|mountain|ocean|forest|nature|sky|sunset/.test(lowerPrompt)) {
    return "landscape";
  }
  if (/animal|bird|cat|dog|wildlife/.test(lowerPrompt)) {
    return "animal";
  }
  if (/food|dish|meal|cuisine/.test(lowerPrompt)) {
    return "food";
  }
  if (/product|item|object|thing/.test(lowerPrompt)) {
    return "product";
  }
  if (/building|architecture|city|street|urban/.test(lowerPrompt)) {
    return "architecture";
  }
  return "general";
}

// Get subject-specific enhancements
function getSubjectEnhancements(subjectType: string): string {
  const enhancements: Record<string, string> = {
    portrait: "expressive eyes, natural skin texture, professional portrait photography",
    landscape: "epic scale, atmospheric perspective, vibrant colors, scenic view",
    animal: "sharp details, natural habitat, wildlife photography style, vivid fur/feathers",
    food: "appetizing presentation, food photography, shallow depth of field, garnished",
    product: "clean background, commercial photography, studio setup, product showcase",
    architecture: "architectural photography, dramatic perspective, structural details",
    general: "well-lit, sharp details, professional quality"
  };
  return enhancements[subjectType] || enhancements.general;
}

// Brand color injection - adds brand colors to prompt for consistent branding
interface BrandColors {
  name: string;
  primaryColor: string;
  secondaryColor?: string;
  style?: string;
}

function injectBrandColors(prompt: string, brand: BrandColors): string {
  const colorTerms: string[] = [];

  // Add primary color as dominant accent
  if (brand.primaryColor) {
    const colorName = getColorName(brand.primaryColor);
    colorTerms.push(`${colorName} (${brand.primaryColor}) as dominant accent color`);
  }

  // Add secondary color if available
  if (brand.secondaryColor) {
    const secondaryName = getColorName(brand.secondaryColor);
    colorTerms.push(`${secondaryName} (${brand.secondaryColor}) secondary accents`);
  }

  // Add brand style if specified
  if (brand.style) {
    colorTerms.push(`${brand.style} aesthetic`);
  }

  if (colorTerms.length === 0) {
    return prompt;
  }

  return `${prompt}, ${colorTerms.join(", ")}, brand consistent, cohesive color scheme`;
}

// Convert hex color to approximate color name
function getColorName(hex: string): string {
  const colorMap: Record<string, string> = {
    "#3B82F6": "blue",
    "#8B5CF6": "purple",
    "#10B981": "green",
    "#EF4444": "red",
    "#F97316": "orange",
    "#FACC15": "yellow",
    "#EC4899": "pink",
    "#14B8A6": "teal",
    "#000000": "black",
    "#FFFFFF": "white",
    "#6B7280": "gray",
  };

  // Check exact match first
  const upperHex = hex.toUpperCase();
  if (colorMap[upperHex]) {
    return colorMap[upperHex];
  }

  // Try to match by hue
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);

  if (r > 200 && g < 100 && b < 100) return "red";
  if (r > 200 && g > 150 && b < 100) return "orange";
  if (r > 200 && g > 200 && b < 100) return "yellow";
  if (r < 100 && g > 200 && b < 100) return "green";
  if (r < 100 && g > 200 && b > 200) return "cyan";
  if (r < 100 && g < 100 && b > 200) return "blue";
  if (r > 150 && g < 100 && b > 200) return "purple";
  if (r > 200 && g < 100 && b > 150) return "pink";
  if (r > 200 && g > 200 && b > 200) return "white";
  if (r < 50 && g < 50 && b < 50) return "black";

  return "accent"; // Fallback
}

// Main prompt enhancer - transforms simple prompts into professional ones
function autoEnhancePrompt(prompt: string): string {
  // If prompt is already detailed (>100 chars) or has quality terms, minimal enhancement
  if (prompt.length > 100 || hasQualityTerms(prompt)) {
    // Just add basic quality boost if missing
    if (!hasQualityTerms(prompt)) {
      return `${prompt}, high quality, detailed`;
    }
    return prompt;
  }

  // Detect what the user is trying to create
  const subjectType = detectSubjectType(prompt);
  const subjectEnhancement = getSubjectEnhancements(subjectType);

  // Pick random quality and lighting terms for variety
  const quality = QUALITY_BOOSTERS[Math.floor(Math.random() * QUALITY_BOOSTERS.length)];
  const lighting = LIGHTING_TERMS[Math.floor(Math.random() * LIGHTING_TERMS.length)];

  // Build enhanced prompt
  const enhancedPrompt = `${prompt}, ${subjectEnhancement}, ${quality}, ${lighting}`;

  return enhancedPrompt;
}

// Apply style enhancement on top of auto-enhancement
function enhancePrompt(prompt: string, style: string): string {
  // First auto-enhance the prompt
  const autoEnhanced = autoEnhancePrompt(prompt);

  // Then add style-specific terms if selected
  if (!style || style === "none") return autoEnhanced;
  const styleBoost = styleEnhancements[style];
  return styleBoost ? `${autoEnhanced}, ${styleBoost}` : autoEnhanced;
}

function getImageSize(
  aspectRatio: string
): { width: number; height: number } {
  const dimensions: Record<string, { width: number; height: number }> = {
    "1:1": { width: 1024, height: 1024 },
    "16:9": { width: 1344, height: 768 },
    "9:16": { width: 768, height: 1344 },
    "4:3": { width: 1152, height: 896 },
    "3:4": { width: 896, height: 1152 },
  };
  return dimensions[aspectRatio] || dimensions["1:1"];
}

// Ideogram uses simple aspect ratio strings like "1:1"
function getIdeogramAspectRatio(aspectRatio: string): string {
  // Ideogram accepts: "1:1", "16:9", "9:16", "4:3", "3:4", etc.
  return aspectRatio || "1:1";
}

// Check if model is Ideogram
function isIdeogramModel(model: string): boolean {
  return model.includes("ideogram");
}

// Generate image - returns the URL from Fal.ai or Runware
export const generate = action({
  args: {
    prompt: v.string(),
    model: v.optional(v.string()),
    aspectRatio: v.optional(
      v.union(
        v.literal("1:1"),
        v.literal("16:9"),
        v.literal("9:16"),
        v.literal("4:3"),
        v.literal("3:4")
      )
    ),
    style: v.optional(v.string()),
    // Brand kit color injection
    applyBrandColors: v.optional(v.boolean()),
    brandColors: v.optional(
      v.object({
        name: v.string(),
        primaryColor: v.string(),
        secondaryColor: v.optional(v.string()),
        style: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args) => {
    const authUser = await authComponent.getAuthUser(ctx);
    if (!authUser) {
      throw new Error("Not authenticated");
    }

    // Check feature access and limits
    const user = await ctx.runQuery(api.users.viewer);
    if (!user) {
      throw new Error("User not found. Please refresh the page.");
    }
    if (!user.features.hasImageGeneration) {
      throw new Error(
        "Image generation is not available on your plan. Upgrade to Pro."
      );
    }

    // Check image limit
    if (user.usage.imagesThisMonth >= user.usage.imagesLimit) {
      throw new Error(
        `LIMIT_REACHED: You've used all ${user.usage.imagesLimit} images this month. Upgrade your plan to generate more images.`
      );
    }

    const model = args.model || "fal-ai/flux/schnell";

    // Check model access based on user's plan
    const userPlan = (user.plan || "FREE") as Plan;
    if (!canAccessModel(userPlan, model)) {
      const requiredPlan = getModelRequiredPlan(model);
      throw new Error(
        `The ${model.split('/').pop()} model requires a ${requiredPlan} plan. Upgrade to access premium models.`
      );
    }
    const aspectRatio = args.aspectRatio || "1:1";
    const style = args.style || "none";

    // Apply brand colors if requested
    let promptWithBrand = args.prompt;
    if (args.applyBrandColors && args.brandColors) {
      promptWithBrand = injectBrandColors(args.prompt, args.brandColors);
    }

    const enhancedPrompt = enhancePrompt(promptWithBrand, style);
    const imageSize = getImageSize(aspectRatio);

    // Determine provider based on model
    const provider = getProvider(model);
    let generatedImageUrl: string;

    if (provider === "runware") {
      // Use Runware for Flux models (93% cost savings)
      const runwareApiKey = process.env.RUNWARE_API_KEY;
      if (!runwareApiKey) {
        // Fallback to Fal.ai if Runware key not configured
        const falApiKey = process.env.FAL_API_KEY;
        if (!falApiKey) {
          throw new Error("Image generation API key not configured");
        }
        generatedImageUrl = await generateWithFal(
          enhancedPrompt,
          model,
          imageSize,
          aspectRatio,
          falApiKey
        );
      } else {
        generatedImageUrl = await generateWithRunware(
          enhancedPrompt,
          model,
          imageSize.width,
          imageSize.height,
          runwareApiKey
        );
      }
    } else {
      // Use Fal.ai for Ideogram logos
      const falApiKey = process.env.FAL_API_KEY;
      if (!falApiKey) {
        throw new Error("Fal.ai API key not configured");
      }
      generatedImageUrl = await generateWithFal(
        enhancedPrompt,
        model,
        imageSize,
        aspectRatio,
        falApiKey
      );
    }

    // Increment usage after successful generation
    await ctx.runMutation(api.users.incrementImageUsage);

    return {
      url: generatedImageUrl,
      prompt: args.prompt,
      model,
      aspectRatio,
      style,
    };
  },
});

// Build cinematic product photography prompt
// Based on world-class product photographer prompt template
function buildProductPhotographyPrompt(
  productDescription: string,
  sceneDescription: string,
  brandColor: string,
  customPrompt?: string
): string {
  // Get color name for the prompt
  const colorName = getColorName(brandColor);

  // Build the comprehensive prompt
  const prompt = `World-class product photography. ${productDescription}, placed centrally on a realistic surface appropriate for the scene.

Scene: ${sceneDescription}${customPrompt ? `, ${customPrompt}` : ''}.

Cinematic background with shallow depth of field (beautiful bokeh), keeping sharp focus on the product. Soft professional cinematic lighting (golden hour side-lighting) creating deep shadows and bright highlights, making the product look premium and tactile.

Apply a smooth artistic ${colorName} (${brandColor}) color gradient overlay starting from the top edge of the frame, slowly fading to transparency towards the middle, tinting the upper part and product highlights with the brand color.

Photorealistic, high-resolution, luxurious, professional, high-end advertisement, commercial quality, centered composition, 8K detail.`;

  return prompt;
}

// Generate product photography using Flux Pro 1.1
// Creates cinematic product shots with brand color gradients
export const generateProductShot = action({
  args: {
    imageUrl: v.string(), // Reference product image (base64 or URL)
    productDescription: v.string(), // Required: description of the product
    scenePreset: v.optional(v.string()), // Preset scene key
    customScene: v.optional(v.string()), // Custom scene description
    aspectRatio: v.optional(v.string()), // Output size
    brandColor: v.optional(v.string()), // Brand color hex (e.g., "#FFD700")
  },
  handler: async (ctx, args) => {
    const authUser = await authComponent.getAuthUser(ctx);
    if (!authUser) {
      throw new Error("Not authenticated");
    }

    // Check feature access and limits
    const user = await ctx.runQuery(api.users.viewer);
    if (!user) {
      throw new Error("User not found. Please refresh the page.");
    }
    if (!user.features.hasImageGeneration) {
      throw new Error(
        "Product photography is not available on your plan. Upgrade to Pro."
      );
    }

    // Check image limit
    if (user.usage.imagesThisMonth >= user.usage.imagesLimit) {
      throw new Error(
        `LIMIT_REACHED: You've used all ${user.usage.imagesLimit} images this month. Upgrade your plan to generate more images.`
      );
    }

    // Use Runware for Flux Pro 1.1
    const runwareApiKey = process.env.RUNWARE_API_KEY;
    if (!runwareApiKey) {
      throw new Error("Runware API key not configured");
    }

    // Scene presets mapping - cinematic descriptions for world-class product photography
    const scenePresets: Record<string, string> = {
      "studio-white": "Clean white studio surface with soft professional lighting, gentle shadows, crisp e-commerce aesthetic",
      "marble-surface": "Polished white marble countertop with elegant reflections, soft natural window light, luxury aesthetic",
      "wooden-table": "Rustic warm oak wood table with natural grain texture visible, soft golden hour side lighting, cozy artisan feel",
      "kitchen-counter": "Modern white kitchen counter with bright daylight from window, clean minimal background, lifestyle home setting",
      "living-room": "Coffee table in modern living room with soft ambient lighting, blurred cozy interior background, warm lifestyle tones",
      "nature-outdoor": "Natural stone surface outdoors with lush green plants softly blurred in background, dappled sunlight, organic fresh feel",
      "gradient-modern": "Smooth gradient background from white to soft gray, professional studio lighting, modern minimalist aesthetic",
      "beach-seaside": "Light sandy surface with soft ocean waves blurred in background, warm golden sunset lighting, summer vacation mood",
      "concrete-urban": "Raw concrete surface with industrial texture, dramatic side lighting, urban loft aesthetic, edgy modern vibe",
      "fabric-textile": "Soft cream linen fabric with gentle folds, diffused natural light, elegant boutique styling, romantic feel",
    };

    // Get scene description
    let sceneDescription = args.customScene || "";
    if (args.scenePreset && scenePresets[args.scenePreset]) {
      sceneDescription = scenePresets[args.scenePreset];
      // If custom scene also provided, append it
      if (args.customScene) {
        sceneDescription = `${sceneDescription}, ${args.customScene}`;
      }
    }

    if (!sceneDescription) {
      sceneDescription = "Professional studio setting with clean background and soft lighting";
    }

    // Default brand color if not provided
    const brandColor = args.brandColor || "#FACC15"; // Default to POSTAIFY yellow

    // Build the cinematic product photography prompt
    const prompt = buildProductPhotographyPrompt(
      args.productDescription,
      sceneDescription,
      brandColor,
      args.customScene
    );

    // Determine output dimensions
    const dimensions = args.aspectRatio === "16:9"
      ? { width: 1344, height: 768 }
      : args.aspectRatio === "9:16"
      ? { width: 768, height: 1344 }
      : { width: 1024, height: 1024 }; // Default square

    // Call Runware with Flux Pro 1.1 using image-to-image
    // The input image serves as reference for the product appearance
    const response = await fetch("https://api.runware.ai/v1", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${runwareApiKey}`,
      },
      body: JSON.stringify([
        {
          taskType: "imageInference",
          taskUUID: crypto.randomUUID(),
          positivePrompt: prompt,
          model: "civitai:618692@691639", // Flux Pro 1.1
          width: dimensions.width,
          height: dimensions.height,
          numberResults: 1,
          outputFormat: "png",
          outputQuality: 95,
          outputType: "URL",
          includeCost: false,
          CFGScale: 7,
          scheduler: "FlowMatchEulerDiscreteScheduler",
          steps: 25, // Higher steps for better quality
          // Image-to-image: use uploaded product as reference
          inputImage: args.imageUrl,
          strength: 0.65, // Balance between keeping product identity and applying scene (0.6-0.7 recommended)
        },
      ]),
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => "");
      if (response.status === 401) {
        throw new Error("Invalid Runware API key");
      }
      if (response.status === 402) {
        throw new Error("Insufficient Runware credits");
      }
      throw new Error(
        `Failed to generate product shot: ${errorText || response.statusText}`
      );
    }

    const result = (await response.json()) as {
      data?: Array<{ imageURL?: string }>;
    };

    if (!result.data || result.data.length === 0 || !result.data[0].imageURL) {
      throw new Error("No product shot was generated");
    }

    // Increment usage after successful generation
    await ctx.runMutation(api.users.incrementImageUsage);

    return {
      url: result.data[0].imageURL,
      scene: sceneDescription,
      aspectRatio: args.aspectRatio || "1:1",
      prompt: prompt, // Return prompt for debugging/display
    };
  },
});
