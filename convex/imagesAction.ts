"use node";

import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import { authComponent } from "./auth";
import { canAccessModel, getModelRequiredPlan, Plan } from "./lib/planLimits";

// Provider types
type ImageProvider = "runware" | "fal";

// Model to provider mapping - Runware for Flux, Fal.ai for Ideogram/Bria
function getProvider(model: string): ImageProvider {
  if (model.includes("ideogram") || model.includes("bria")) {
    return "fal";
  }
  return "runware";
}

// Runware model ID mapping
// Pricing: https://runware.ai/pricing
// - FLUX.2 [klein] 4B: $0.0006/image (cheapest, sub-second, best for FREE tier)
// - Flux Schnell: $0.0006/image (fast, good quality)
// - Flux Dev: $0.0038/image (higher quality)
// - HiDream-I1 Fast: $0.0032/image (good but 5x more expensive)
function getRunwareModelId(model: string): string {
  const modelMap: Record<string, string> = {
    "fal-ai/flux/schnell": "runware:400@4", // FLUX.2 [klein] 4B - $0.0006, sub-second (FREE tier)
    "fal-ai/flux/dev": "runware:101@1", // Flux Dev - $0.0038 (PRO tier)
    "fal-ai/flux-pro": "civitai:618692@691639", // Flux Pro 1.1 (PRO tier)
    "fal-ai/flux-pro/v1.1": "civitai:618692@691639", // Flux Pro 1.1 (PRO tier)
    "fal-ai/recraft-v3": "runware:2@1", // Recraft V3 (BUSINESS tier)
  };
  return modelMap[model] || "runware:400@4"; // Default to FLUX.2 klein 4B (cheapest)
}

// Runware image generation
async function generateWithRunware(
  prompt: string,
  model: string,
  width: number,
  height: number,
  apiKey: string
): Promise<string> {
  const runwareModel = getRunwareModelId(model);

  const response = await fetch("https://api.runware.ai/v1", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify([
      {
        taskType: "imageInference",
        taskUUID: crypto.randomUUID(),
        positivePrompt: prompt,
        model: runwareModel,
        width,
        height,
        numberResults: 1,
        outputFormat: "PNG", // Runware accepts uppercase
        outputType: "URL",
        includeCost: false,
        CFGScale: 7,
        scheduler: "FlowMatchEulerDiscreteScheduler",
        strength: 0.8,
      },
    ]),
  });

  if (!response.ok) {
    const errorText = await response.text().catch(() => "");
    if (response.status === 401) {
      throw new Error("Invalid Runware API key");
    }
    if (response.status === 402) {
      throw new Error("Insufficient Runware credits");
    }
    throw new Error(
      `Runware API error: ${errorText || response.statusText}`
    );
  }

  const result = (await response.json()) as {
    data?: Array<{ imageURL?: string }>;
  };

  if (!result.data || result.data.length === 0 || !result.data[0].imageURL) {
    throw new Error("No image was generated by Runware");
  }

  return result.data[0].imageURL;
}

// Fal.ai image generation (existing logic)
async function generateWithFal(
  prompt: string,
  model: string,
  imageSize: { width: number; height: number },
  aspectRatio: string,
  apiKey: string
): Promise<string> {
  let requestBody: Record<string, unknown>;

  if (isIdeogramModel(model)) {
    requestBody = {
      prompt,
      aspect_ratio: aspectRatio,
      expand_prompt: true,
      style: "auto",
    };
  } else {
    requestBody = {
      prompt,
      image_size: imageSize,
      num_images: 1,
      enable_safety_checker: true,
      output_format: "png",
    };
  }

  const response = await fetch(`https://fal.run/${model}`, {
    method: "POST",
    headers: {
      Authorization: `Key ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    if (response.status === 401) {
      throw new Error("Invalid Fal.ai API key");
    }
    if (response.status === 402) {
      throw new Error("Insufficient Fal.ai credits");
    }
    const errorText = await response.text().catch(() => "");
    throw new Error(
      `Fal.ai API error: ${errorText || response.statusText}`
    );
  }

  const result = (await response.json()) as {
    images?: Array<{ url: string }>;
  };

  if (!result.images || result.images.length === 0) {
    throw new Error("No image was generated by Fal.ai");
  }

  return result.images[0].url;
}

// Style-specific enhancements
const styleEnhancements: Record<string, string> = {
  none: "",
  photorealistic:
    "photorealistic, highly detailed, professional photography, 8k resolution",
  "digital-art": "digital art style, vibrant colors, detailed illustration",
  illustration: "illustration style, artistic, clean lines, stylized",
  cinematic:
    "cinematic lighting, dramatic atmosphere, movie still, professional color grading",
  minimalist: "minimalist design, clean, simple, elegant, white space",
  vibrant: "vibrant colors, bold, eye-catching, high contrast, energetic",
};

// Quality keywords to add for professional results
const QUALITY_BOOSTERS = [
  "high quality",
  "detailed",
  "professional",
  "sharp focus",
  "well-composed",
];

// Lighting enhancements
const LIGHTING_TERMS = [
  "beautiful lighting",
  "soft natural light",
  "golden hour lighting",
  "studio lighting",
  "dramatic lighting",
];

// Composition terms
const COMPOSITION_TERMS = [
  "rule of thirds",
  "balanced composition",
  "centered subject",
  "dynamic angle",
];

// Check if prompt already has quality/technical terms
function hasQualityTerms(prompt: string): boolean {
  const qualityIndicators = [
    "detailed", "quality", "professional", "8k", "4k", "hd", "realistic",
    "lighting", "composition", "sharp", "vivid", "stunning", "beautiful",
    "masterpiece", "award", "artistic", "render", "resolution"
  ];
  const lowerPrompt = prompt.toLowerCase();
  return qualityIndicators.some(term => lowerPrompt.includes(term));
}

// Detect subject type for context-aware enhancement
function detectSubjectType(prompt: string): string {
  const lowerPrompt = prompt.toLowerCase();

  if (/person|people|man|woman|portrait|face|human/.test(lowerPrompt)) {
    return "portrait";
  }
  if (/landscape|mountain|ocean|forest|nature|sky|sunset/.test(lowerPrompt)) {
    return "landscape";
  }
  if (/animal|bird|cat|dog|wildlife/.test(lowerPrompt)) {
    return "animal";
  }
  if (/food|dish|meal|cuisine/.test(lowerPrompt)) {
    return "food";
  }
  if (/product|item|object|thing/.test(lowerPrompt)) {
    return "product";
  }
  if (/building|architecture|city|street|urban/.test(lowerPrompt)) {
    return "architecture";
  }
  return "general";
}

// Get subject-specific enhancements
function getSubjectEnhancements(subjectType: string): string {
  const enhancements: Record<string, string> = {
    portrait: "expressive eyes, natural skin texture, professional portrait photography",
    landscape: "epic scale, atmospheric perspective, vibrant colors, scenic view",
    animal: "sharp details, natural habitat, wildlife photography style, vivid fur/feathers",
    food: "appetizing presentation, food photography, shallow depth of field, garnished",
    product: "clean background, commercial photography, studio setup, product showcase",
    architecture: "architectural photography, dramatic perspective, structural details",
    general: "well-lit, sharp details, professional quality"
  };
  return enhancements[subjectType] || enhancements.general;
}

// Brand color injection - adds brand colors to prompt for consistent branding
interface BrandColors {
  name: string;
  primaryColor: string;
  secondaryColor?: string;
  style?: string;
}

function injectBrandColors(prompt: string, brand: BrandColors): string {
  const colorTerms: string[] = [];

  // Add primary color as dominant accent
  if (brand.primaryColor) {
    const colorName = getColorName(brand.primaryColor);
    colorTerms.push(`${colorName} (${brand.primaryColor}) as dominant accent color`);
  }

  // Add secondary color if available
  if (brand.secondaryColor) {
    const secondaryName = getColorName(brand.secondaryColor);
    colorTerms.push(`${secondaryName} (${brand.secondaryColor}) secondary accents`);
  }

  // Add brand style if specified
  if (brand.style) {
    colorTerms.push(`${brand.style} aesthetic`);
  }

  if (colorTerms.length === 0) {
    return prompt;
  }

  return `${prompt}, ${colorTerms.join(", ")}, brand consistent, cohesive color scheme`;
}

// Convert hex color to approximate color name
function getColorName(hex: string): string {
  const colorMap: Record<string, string> = {
    "#3B82F6": "blue",
    "#8B5CF6": "purple",
    "#10B981": "green",
    "#EF4444": "red",
    "#F97316": "orange",
    "#FACC15": "yellow",
    "#EC4899": "pink",
    "#14B8A6": "teal",
    "#000000": "black",
    "#FFFFFF": "white",
    "#6B7280": "gray",
  };

  // Check exact match first
  const upperHex = hex.toUpperCase();
  if (colorMap[upperHex]) {
    return colorMap[upperHex];
  }

  // Try to match by hue
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);

  if (r > 200 && g < 100 && b < 100) return "red";
  if (r > 200 && g > 150 && b < 100) return "orange";
  if (r > 200 && g > 200 && b < 100) return "yellow";
  if (r < 100 && g > 200 && b < 100) return "green";
  if (r < 100 && g > 200 && b > 200) return "cyan";
  if (r < 100 && g < 100 && b > 200) return "blue";
  if (r > 150 && g < 100 && b > 200) return "purple";
  if (r > 200 && g < 100 && b > 150) return "pink";
  if (r > 200 && g > 200 && b > 200) return "white";
  if (r < 50 && g < 50 && b < 50) return "black";

  return "accent"; // Fallback
}

// Main prompt enhancer - transforms simple prompts into professional ones
function autoEnhancePrompt(prompt: string): string {
  // If prompt is already detailed (>100 chars) or has quality terms, minimal enhancement
  if (prompt.length > 100 || hasQualityTerms(prompt)) {
    // Just add basic quality boost if missing
    if (!hasQualityTerms(prompt)) {
      return `${prompt}, high quality, detailed`;
    }
    return prompt;
  }

  // Detect what the user is trying to create
  const subjectType = detectSubjectType(prompt);
  const subjectEnhancement = getSubjectEnhancements(subjectType);

  // Pick random quality and lighting terms for variety
  const quality = QUALITY_BOOSTERS[Math.floor(Math.random() * QUALITY_BOOSTERS.length)];
  const lighting = LIGHTING_TERMS[Math.floor(Math.random() * LIGHTING_TERMS.length)];

  // Build enhanced prompt
  const enhancedPrompt = `${prompt}, ${subjectEnhancement}, ${quality}, ${lighting}`;

  return enhancedPrompt;
}

// Apply style enhancement on top of auto-enhancement
function enhancePrompt(prompt: string, style: string): string {
  // First auto-enhance the prompt
  const autoEnhanced = autoEnhancePrompt(prompt);

  // Then add style-specific terms if selected
  if (!style || style === "none") return autoEnhanced;
  const styleBoost = styleEnhancements[style];
  return styleBoost ? `${autoEnhanced}, ${styleBoost}` : autoEnhanced;
}

function getImageSize(
  aspectRatio: string
): { width: number; height: number } {
  const dimensions: Record<string, { width: number; height: number }> = {
    "1:1": { width: 1024, height: 1024 },
    "16:9": { width: 1344, height: 768 },
    "9:16": { width: 768, height: 1344 },
    "4:3": { width: 1152, height: 896 },
    "3:4": { width: 896, height: 1152 },
  };
  return dimensions[aspectRatio] || dimensions["1:1"];
}

// Ideogram uses simple aspect ratio strings like "1:1"
function getIdeogramAspectRatio(aspectRatio: string): string {
  // Ideogram accepts: "1:1", "16:9", "9:16", "4:3", "3:4", etc.
  return aspectRatio || "1:1";
}

// Check if model is Ideogram
function isIdeogramModel(model: string): boolean {
  return model.includes("ideogram");
}

// Generate image - returns the URL from Fal.ai or Runware
export const generate = action({
  args: {
    prompt: v.string(),
    model: v.optional(v.string()),
    aspectRatio: v.optional(
      v.union(
        v.literal("1:1"),
        v.literal("16:9"),
        v.literal("9:16"),
        v.literal("4:3"),
        v.literal("3:4")
      )
    ),
    style: v.optional(v.string()),
    // Brand kit color injection
    applyBrandColors: v.optional(v.boolean()),
    brandColors: v.optional(
      v.object({
        name: v.string(),
        primaryColor: v.string(),
        secondaryColor: v.optional(v.string()),
        style: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args) => {
    const authUser = await authComponent.getAuthUser(ctx);
    if (!authUser) {
      throw new Error("Not authenticated");
    }

    // Check feature access and limits
    const user = await ctx.runQuery(api.users.viewer);
    if (!user) {
      throw new Error("User not found. Please refresh the page.");
    }
    if (!user.features.hasImageGeneration) {
      throw new Error(
        "Image generation is not available on your plan. Upgrade to Pro."
      );
    }

    // Check image limit
    if (user.usage.imagesThisMonth >= user.usage.imagesLimit) {
      throw new Error(
        `LIMIT_REACHED: You've used all ${user.usage.imagesLimit} images this month. Upgrade your plan to generate more images.`
      );
    }

    const model = args.model || "fal-ai/flux/schnell";

    // Check model access based on user's plan
    const userPlan = (user.plan || "FREE") as Plan;
    if (!canAccessModel(userPlan, model)) {
      const requiredPlan = getModelRequiredPlan(model);
      throw new Error(
        `The ${model.split('/').pop()} model requires a ${requiredPlan} plan. Upgrade to access premium models.`
      );
    }
    const aspectRatio = args.aspectRatio || "1:1";
    const style = args.style || "none";

    // Apply brand colors if requested
    let promptWithBrand = args.prompt;
    if (args.applyBrandColors && args.brandColors) {
      promptWithBrand = injectBrandColors(args.prompt, args.brandColors);
    }

    const enhancedPrompt = enhancePrompt(promptWithBrand, style);
    const imageSize = getImageSize(aspectRatio);

    // Determine provider based on model
    const provider = getProvider(model);
    let generatedImageUrl: string;

    if (provider === "runware") {
      // Use Runware for Flux models (93% cost savings)
      const runwareApiKey = process.env.RUNWARE_API_KEY;
      if (!runwareApiKey) {
        // Fallback to Fal.ai if Runware key not configured
        const falApiKey = process.env.FAL_API_KEY;
        if (!falApiKey) {
          throw new Error("Image generation API key not configured");
        }
        generatedImageUrl = await generateWithFal(
          enhancedPrompt,
          model,
          imageSize,
          aspectRatio,
          falApiKey
        );
      } else {
        generatedImageUrl = await generateWithRunware(
          enhancedPrompt,
          model,
          imageSize.width,
          imageSize.height,
          runwareApiKey
        );
      }
    } else {
      // Use Fal.ai for Ideogram logos
      const falApiKey = process.env.FAL_API_KEY;
      if (!falApiKey) {
        throw new Error("Fal.ai API key not configured");
      }
      generatedImageUrl = await generateWithFal(
        enhancedPrompt,
        model,
        imageSize,
        aspectRatio,
        falApiKey
      );
    }

    // Increment usage after successful generation
    await ctx.runMutation(api.users.incrementImageUsage);

    return {
      url: generatedImageUrl,
      prompt: args.prompt,
      model,
      aspectRatio,
      style,
    };
  },
});

// Product scene description enhancer
function enhanceProductScene(sceneDescription: string, customPrompt?: string): string {
  // Quality keywords for realistic product photography
  const qualityKeywords = "professional product photography, sharp focus, realistic lighting, natural shadows, high detail, commercial quality, centered composition";

  // Combine scene description with custom prompt if provided
  let finalDescription = sceneDescription;
  if (customPrompt && customPrompt.trim()) {
    finalDescription = `${sceneDescription}, ${customPrompt.trim()}`;
  }

  // Add product photography quality boost
  return `${finalDescription}, ${qualityKeywords}`;
}

// Generate product photography - places product in professional scene
export const generateProductShot = action({
  args: {
    imageUrl: v.string(), // URL of the product image
    scenePreset: v.optional(v.string()), // Preset scene key
    customScene: v.optional(v.string()), // Custom scene description
    aspectRatio: v.optional(v.string()), // Output size
    closeUp: v.optional(v.boolean()), // Close-up framing (product fills more of frame)
  },
  handler: async (ctx, args) => {
    const authUser = await authComponent.getAuthUser(ctx);
    if (!authUser) {
      throw new Error("Not authenticated");
    }

    // Check feature access and limits
    const user = await ctx.runQuery(api.users.viewer);
    if (!user) {
      throw new Error("User not found. Please refresh the page.");
    }
    if (!user.features.hasImageGeneration) {
      throw new Error(
        "Product photography is not available on your plan. Upgrade to Pro."
      );
    }

    // Check image limit
    if (user.usage.imagesThisMonth >= user.usage.imagesLimit) {
      throw new Error(
        `LIMIT_REACHED: You've used all ${user.usage.imagesLimit} images this month. Upgrade your plan to generate more images.`
      );
    }

    const falApiKey = process.env.FAL_API_KEY;
    if (!falApiKey) {
      throw new Error("Fal.ai API key not configured");
    }

    // Scene presets mapping - optimized for realistic close-up product shots
    const scenePresets: Record<string, string> = {
      "studio-white": "Product on clean white surface, soft studio lighting with gentle shadows, professional e-commerce photography, crisp and clear",
      "marble-surface": "Product placed on polished white marble countertop, elegant reflections, soft natural window light, luxury aesthetic, realistic shadows",
      "wooden-table": "Product on warm oak wood table, natural grain texture visible, soft golden hour side lighting, cozy artisan feel, subtle shadows",
      "kitchen-counter": "Product on modern white kitchen counter, bright daylight from window, clean minimal background, lifestyle home setting, natural shadows",
      "living-room": "Product on coffee table in modern living room, soft ambient lighting, blurred cozy interior background, lifestyle photography, warm tones",
      "nature-outdoor": "Product on natural stone surface outdoors, lush green plants softly blurred in background, dappled sunlight, organic fresh feel",
      "gradient-modern": "Product floating on smooth gradient background from white to soft gray, professional studio lighting, modern minimalist, soft shadow below",
      "beach-seaside": "Product on light sandy surface, soft ocean waves blurred in background, warm golden sunset lighting, summer vacation mood",
      "concrete-urban": "Product on raw concrete surface, industrial texture, dramatic side lighting, urban loft aesthetic, strong shadows, edgy modern",
      "fabric-textile": "Product resting on soft cream linen fabric with gentle folds, diffused natural light, elegant boutique styling, soft romantic feel",
    };

    // Get scene description
    let sceneDescription = args.customScene || "";
    if (args.scenePreset && scenePresets[args.scenePreset]) {
      sceneDescription = scenePresets[args.scenePreset];
      // If custom scene also provided, append it
      if (args.customScene) {
        sceneDescription = `${sceneDescription}, ${args.customScene}`;
      }
    }

    if (!sceneDescription) {
      sceneDescription = "Professional product photography, clean background, studio lighting";
    }

    // Enhance the scene description
    const enhancedScene = enhanceProductScene(sceneDescription);

    // Determine output size - keep around 1M pixels for optimal quality
    const shotSize = args.aspectRatio === "16:9"
      ? [1200, 675]
      : args.aspectRatio === "9:16"
      ? [675, 1200]
      : [1000, 1000]; // Default square

    // Use manual_padding for closer, more realistic product placement
    // Smaller padding = larger/closer product in frame
    const isCloseUp = args.closeUp !== false; // Default to close-up (true)

    // Close-up: smaller padding (50-80px) = product fills ~70% of frame
    // Normal: larger padding (120-180px) = product fills ~50% of frame
    const paddingValues = isCloseUp
      ? args.aspectRatio === "16:9"
        ? [80, 80, 50, 50]    // Close-up landscape
        : args.aspectRatio === "9:16"
        ? [50, 50, 80, 60]    // Close-up portrait
        : [60, 60, 60, 50]    // Close-up square
      : args.aspectRatio === "16:9"
        ? [180, 180, 100, 100] // Normal landscape
        : args.aspectRatio === "9:16"
        ? [100, 100, 180, 120] // Normal portrait
        : [140, 140, 140, 100]; // Normal square

    // Call Bria Product Shot API
    const response = await fetch("https://fal.run/fal-ai/bria/product-shot", {
      method: "POST",
      headers: {
        Authorization: `Key ${falApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        image_url: args.imageUrl,
        scene_description: enhancedScene,
        optimize_description: true,
        num_results: 1,
        fast: false, // Higher quality
        placement_type: "manual_padding",
        padding_values: paddingValues,
        shot_size: shotSize,
        original_quality: true, // Preserve product quality
      }),
    });

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error("Invalid Fal.ai API key");
      }
      if (response.status === 402) {
        throw new Error("Insufficient Fal.ai credits");
      }
      const errorText = await response.text().catch(() => "");
      throw new Error(
        `Failed to generate product shot: ${errorText || response.statusText}`
      );
    }

    const result = (await response.json()) as {
      images?: Array<{ url: string }>;
    };

    if (!result.images || result.images.length === 0) {
      throw new Error("No product shot was generated");
    }

    // Increment usage after successful generation
    await ctx.runMutation(api.users.incrementImageUsage);

    return {
      url: result.images[0].url,
      scene: sceneDescription,
      aspectRatio: args.aspectRatio || "1:1",
    };
  },
});
